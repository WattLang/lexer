;One way of doing comments (line comments)
;-=-=-=-=-=-=-=-=-=-=-=
;Section 3.5 Iteration and Recursion
;-=-=-=-=-=-=-=-=-=-=-=
;

(defun sqrt-iter (guess x)
  (if (good-enough-p guess x)
      guess
      (sqrt-iter (improve guess x) x)))

(defun improve (guess x)
  (mean (list guess (/ x guess))))

;see format page 121-122

(defun good-enough-p (guess x)
  (format t "~% Guess =~7,4f     Guess^2 = ~7,4f    Error= ~7,4f" guess
          (* guess guess) (abs (- (* guess guess) x)))
  (< (abs (- (* guess guess) x)) .001))

(defun factorial (n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))

(defun fact-iter (product counter n)
  (if (> counter n)
      product
      (fact-iter (* counter product) (+ counter 1) n)))

(defun factorial (n)
  (fact-iter 1 1 n))

(dotimes (i 10)
         (format t "~% ~d" i))

(dolist (i (* (iseq 10) 2))
        (format t "~% ~d" i))

#| Another way of doing comments (block comments)
-=-=-=-=-=-=-=-=-=-=-=
Section 3.5 Scope of definition
-=-=-=-=-=-=-=-=-=-=-=
|#

;1
(def x 1)
(defun f (x)
  (+ x 1))
(f 2)

;2
(def a 10)
(defun f (x)
  (+ x a))
(f 2)

;3
(defun g (a)
  (f 2))

;exercise 3.5

(def x 3)
(def y 7)

(defun f (x)
  (+ x y))

(defun g (y)
  (* x y))

(defun h (x y)
  (+ (f y)
     (g x)))

;here are the intermediate results of the last part of the assignment
;(h 4 13) = (f 13) + (g 4) = (+ 13 7) + (* 3 4) = 20 + 12 = 32

;(h (f 2) (g 6)) = (h (+ 2 7) (* 3 6)) = (h 9 18)
;(h 9 18) = (f 18) + (g 9) = (+ 25 27) = 52



#|
-=-=-=-=-=-=-=-=-=-=-=
Section 3.5.2 Local Variables
-=-=-=-=-=-=-=-=-=-=-=
|#

;let and let*

;define project by prefix algebra (hard to read)
(defun project (y x)
  (* (/ (sum (* x y)) (sum (* x x))) x))

(project '(1 3) '(1 1))

;define project using let
(defun project (y x)
  (let (
        (ip-xy (sum (* x y)))
        (ip-xx (sum (* x x)))
        )
    (* (/ ip-xy ip-xx) x)))

;next definition doesn't work
(defun project (y x)
  (let (
        (ip-xy (sum (* x y)))
        (ip-xx (sum (* x x)))
        (coef  (/ ip-xy ip-xx))
        )
    (* coef x)))

;this works but is too complicated (nested lets are hard to read)
(defun project (y x)
  (let (
        (ip-xy (sum (* x y)))
        (ip-xx (sum (* x x)))
        )
    (let (
          (coef  (/ ip-xy ip-xx))
          )
      (* coef x))))

;use let*
(defun project (y x)
  (let* (
         (ip-xy (sum (* x y)))
         (ip-xx (sum (* x x)))
         (coef  (/ ip-xy ip-xx))
         )
    (* coef x)))

;usually format it this way
(defun project (y x)
  (let* ((ip-xy (sum (* x y)))
         (ip-xx (sum (* x x)))
         (coef  (/ ip-xy ip-xx)))
    (* coef x)))


#|
-=-=-=-=-=-=-=-=-=-=-=
Section 3.5.3 Local Functions
-=-=-=-=-=-=-=-=-=-=-=
|#

;use flet to define project using local inner product function
(defun project (y x)
  (flet (
         (ip (x y) (sum (* x y))) ; this is the local function ip
         )
    (* (/ (ip x y) (ip x x)) x)))

;use nested flets to define (not good, but works)
(defun project (y x)
  (flet (
         (ip (x y) (sum (* x y))) ; this is the local function ip
         )
    (flet (
           (coef (x y) (/ (ip x y) (ip x x)))
           )
      (* (coef x y) x))))

;use flet* (ha, ha, ha!) --- labels --- to define project
(defun project (y x)
  (labels (
           (ip (x y) (sum (* x y))) ; this is the local function ip
           (coef (x y) (/ (ip x y) (ip x x)))
           )
      (* (coef x y) x)))

#|
-=-=-=-=-=-=-=-=-=-=-=
Section 3.6.1 Anonymous (throw-away) Functions
-=-=-=-=-=-=-=-=-=-=-=
|#

(defun f (x)
  (+ (* 2 x) (^ x 2)))
(plot-function #'f -2 3)

(lambda (x)
  (+ (* 2 x) (^ x 2)))

(
 (lambda (x)
   (+ (* 2 x) (^ x 2)))
 1)

(plot-function
 #'(lambda (x) (+ (* 2 x) (^ x 2)))
 -2 3)

#|
-=-=-=-=-=-=-=-=-=-=-=
Section 3.6.2 Using Function Arguments
-=-=-=-=-=-=-=-=-=-=-=
|#

;funcall -
;takes a function argument and as many arguments as the function needs
;useful when you know in advance the number of arguments

(funcall
 #'(lambda (x) (^ x 2)) ; the function x^2
 2)                     ; the argument 2

;apply -
;takes a function argument and a list of arguments
;effectively moves the function inside the list

(apply #'send p :abline (0 1)) ; equivalent to
(send :abline 0 1)

;so we can make a previous example more elegant:

(def travel-space (list 12.8 12.9 12.9 13.6 14.5 14.6 15.1 17.5 19.5 20.8))
(def separation (list 5.5 6.2 6.3 7.0 7.8 8.3 7.1 10.0 10.8 11.0))
(setf plot (plot-points travel-space separation))
(def bikes (regression-model travel-space separation))
(setf coefs (send bikes :coef-estimates))
;and we change (send plot :abline (first coefs) (second coefs)) to
(apply #'send plot :abline coefs)
